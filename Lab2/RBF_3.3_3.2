import numpy as np
import matplotlib.pyplot as plt
import math
import sys
import scipy as sp
import numpy.linalg as la

class RBF:
  center=0
  variance=0
  def __init__(self,center, variance):
    self.center = center
    self.variance = variance

  def gFunc(self,inputVec):
    output=np.zeros(inputVec.size)
    if inputVec.size == 1:
      dist=self.center-inputVec
      output=math.exp((-((dist)**2))/(2*self.variance))
      return output
    else:
      for i in range(inputVec.size):
        dist=self.center-inputVec[i]
        output[i]=math.exp((-((dist)**2))/(2*self.variance))
      return output

def makeRBFNodes(num, variance):
  #make num Guassian RBFs
  centers=np.linspace(0,2*math.pi, num)
  rbfnodes=np.zeros(centers.size, dtype=object)
  for i in range(centers.size):
    node=RBF(centers[i],variance)
    rbfnodes[i]=RBF(centers[i],variance)
  return rbfnodes

def sin2x(x):
  return np.sin(2*x)

def square2x(x):
  y = np.sin(2*x)
  if y == 0:
    return 0
  elif y>0:
    return 1
  elif y<0:
    return -1
  
numRbfNodes= 45
numEpochs = 100
variance = .01
rbfVector = makeRBFNodes(numRbfNodes,variance)
#roughly these are the steps
weights = .1* np.random.randn(numRbfNodes)
patterns = np.arange(0, 2*math.pi, 0.1)
patterns = patterns.T
sin2xVectorized = np.vectorize(sin2x)
targets =sin2xVectorized(patterns)
targets = targets.T

testdata = np.arange(0.05, 2*math.pi, 0.1)
testdata = testdata.T
testTargets =(sin2xVectorized(testdata)).T

def batch(numRbfNodes, rbfVector, patterns, numEpochs, targets, testdata, testTargets):
  phiMatrix=[]
  weights = .1* np.random.randn(numRbfNodes+1)
  #print("weights shape: ",weights.shape)
  for j in range(0, numRbfNodes):
    column=rbfVector[j].gFunc(patterns)
    phiMatrix.append(column.tolist())
  phiMatrix=np.asarray(phiMatrix)
  #print("before appending phimatrix shape: ",phiMatrix.shape)
  ones = np.ones(patterns.size)
  phiMatrix=np.row_stack((phiMatrix,ones.T))
  #print("after stacking phi shape: ",phiMatrix.shape)
  phiTphi=phiMatrix.dot(phiMatrix.T)
  #print("phiphi shape: ",phiTphi.shape)
  ll=la.lstsq(phiTphi,phiMatrix.dot(targets))
  weights=ll[0]

  for i in range(0, numEpochs):
    f=(phiMatrix.T).dot(weights)
    phiTphi=phiMatrix.dot(phiMatrix.T)
    ll=la.lstsq(phiTphi,phiMatrix.dot(targets))
    weights=ll[0]
  error=np.average(np.absolute(f - targets))

  #done training, now run test data through it
  phiMatrix=[]
  for j in range(0, numRbfNodes):
    column=rbfVector[j].gFunc(testdata)
    phiMatrix.append(column.tolist())
  phiMatrix=np.asarray(phiMatrix)
  phiMatrix=np.row_stack((phiMatrix,ones.T))
  testoutput=(phiMatrix.T).dot(weights)
  testError=np.average(np.absolute(testoutput - testTargets))
  print(testError)
  return [testoutput,error,testError]

'''
#train batch for sin(2x)
temp=batch(numRbfNodes, rbfVector, patterns, numEpochs, targets, testdata, testTargets)
testoutput=temp[0]
#print(temp[2])
#graph
xvals=np.linspace(0,2*math.pi, 1000)
plt.plot(xvals, sin2xVectorized(xvals), color='cyan', label='Actual Sin(2x) Curve')
plt.plot(testdata, testoutput, color='orange',label='Curve Generated by Test Data')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-1.1,1.1)
plt.title('Function Approximation of Sin(2x)')
plt.show()
'''

def generateNodesGraph(patterns, numEpochs, targets, testdata, testTargets):
  errorArray=[]
  testErrorArray=[]
  start=1
  end=65
  step=1
  nodes=start
  while nodes<end:
    rbfVector=makeRBFNodes(nodes,0.2)
    temp=batch(nodes, rbfVector, patterns, numEpochs, targets, testdata, testTargets)
    errorArray.append(temp[1])
    testErrorArray.append(temp[2])
    nodes+=step
  xvals=np.linspace(start,end-step,end/step-1)
  errorArray=np.asarray(errorArray)
  testErrorArray=np.asarray(testErrorArray)
  #print(errorArray)
  #print(xvals.shape)
  #print(errorArray.shape)
  plt.title('Number RBF Nodes vs Test Error')
  plt.xlim(8,80)
  plt.ylim(0,.01)
  plt.xlabel('Number RBF Nodes')
  plt.ylabel('Absolute Relative Error')
#  plt.plot(xvals,np.asarray(errorArray), color='blue', label='Training Set')
  plt.plot(xvals,np.asarray(errorArray), color='red', label='Test Set')
#  plt.legend()
  plt.show()


#generateNodesGraph(patterns,numEpochs,targets,testdata,testTargets)
'''
#testing Square
patterns = np.arange(0, 2*math.pi, 0.1)
patterns = patterns.T
square2xVectorized = np.vectorize(square2x)
targets =square2xVectorized(patterns)
targets = targets.T
weights = .1* np.random.randn(numRbfNodes)
testdata = np.arange(0.05, 2*math.pi, 0.1)
testdata = testdata.T
#print(targets)
nodes=80
rbfVector=makeRBFNodes(nodes, 0.005)
testTargets =(square2xVectorized(testdata)).T
print(testTargets)
testoutput=batch(nodes, rbfVector, patterns, numEpochs, targets, testdata, testTargets)
print(testoutput[2])

patterns = np.arange(0, 2*math.pi, 0.1)
noise = np.random.normal(0, 0.3, size=patterns.size)
patterns = patterns + (noise)
patterns = patterns.T
weights = .1* np.random.randn(numRbfNodes)
targets =sin2xVectorized(patterns)
targets = targets.T

'''

'''
patterns = np.arange(0, 2*math.pi, 0.1)
noise = np.random.normal(0, math.sqrt(0.1), size=patterns.size)
patterns = patterns + (noise)
patterns = patterns.T
weights = .1* np.random.randn(numRbfNodes)
targets =sin2xVectorized(patterns)
targets = targets.T

batch(numRbfNodes, rbfVector, patterns, numEpochs, weights, targets)
'''
def incremental(patterns, numRbfNodes, rbfVector, eta, weights, numEpochs, targets, testdata, testTargets):
  for k in range(0, numEpochs):
    np.random.shuffle(patterns)
    for i in range(0, len(patterns)):
      phi = np.zeros(numRbfNodes)
      for j in range (0, numRbfNodes):
        phi[j] = rbfVector[j].gFunc(patterns[i][0])
      f = phi.dot(weights)
      #print(f)
      deltaW = eta * (sin2x(patterns[i][1]) - f) * phi
      weights = weights + deltaW
    #print(np.average(np.absolute(sin2x(patterns[i][1]) - f)))
  return weights

def testIncremental(numRbfNodes, rbfVector,  weights, numEpochs, testdata, testTargets):
  #test with one run through batch
  phiMatrix=[]
  for j in range(0, numRbfNodes):
    column=rbfVector[j].gFunc(testdata)
    phiMatrix.append(column.tolist())
  phiMatrix=np.asarray(phiMatrix)
  testoutput=(phiMatrix.T).dot(weights)
  testError=np.average(np.absolute(testoutput - testTargets))
  return testError

patterns = np.arange(0, 2*math.pi, 0.1)
noise = np.random.normal(0, 0.3, size=patterns.size)
patternsWithNoise = patterns + noise
bothPatterns = zip(patternsWithNoise, patterns)
#print(bothPatterns)
patterns = patterns.T
weights = .1* np.random.randn(numRbfNodes)
targets =sin2xVectorized(patterns)
targets = targets.T
testdata = np.arange(0.05, 2*math.pi, 0.1)
testdata = testdata.T
testTargets =(sin2xVectorized(testdata)).T

weights=incremental(bothPatterns, numRbfNodes, rbfVector, .001, weights, 1000, targets, testdata,testTargets)
print(testIncremental(numRbfNodes,rbfVector,weights,1,testdata,testTargets))

#Hence, leveraging robustness by randomly adding noise to input turns out to be a better way to 
		#avoid overfitting by making outputs impervious to small perturbations in input.



#delta rule
